####简介 : 
```
该程序只需要输入一个序列号 , 并不需要输入账号等其他数据
这样的话 , 那么这个序列号应该是唯一的
那么其验证的应该为 : 
1. 获取用户输入
2. 处理用户输入
3. 进行对比
```
####分析流程 : 
ida 载入定位到关键函数 : 
```C
signed int sub_40110B()
{
  unsigned int v0; // eax@1
  signed int result; // eax@3

  v0 = lstrlenA(String);
  if ( v0 > 8 ) // 输入的字符串长度不能大于 8
    goto LABEL_10;
  if ( v0 < 1 ) // 字符串不能小于 1
    return 111;
  if ( 825440054 != *(_DWORD *)String || 926102068 != *(_DWORD *)&String[4] ) // 如果该分支成立 , 则弹出失败的提示框
  {
LABEL_10:
    MessageBoxA(unk_4030BD, aBestLuckTheNex, Caption, 0x10u);
    result = 0;
  }
  else // 成功
  {
    aThePasswordIs[17] = 39;
    aThePasswordIs[23] = 39;
    MessageBoxA(unk_4030BD, aThePasswordIs, aCongratulation, 0x30u);
    result = 0;
  }
  return result;
}
```
分析一下这里 if 分支不成立的条件 : 
```
825440054 != *(_DWORD *)String || 926102068 != *(_DWORD *)&String[4]
当将 String 以双字(4 字节)的长度读入后 , 判断其于 825440054 的大小
当将 String的 4-8字节 以双字(4 字节)的长度读入后 , 判断其于 926102068 的大小
当上述两个条件都成立的时候 if 分支不成立
因此我们只需要搞清楚 字符串 和 整形在内存中的存储方式即可
例如 : 
字符串 : "I LOVE YOU!"
0x00000000 -> 0x49
0x00000001 -> 0x20
0x00000002 -> 0x4C
0x00000003 -> 0x4F
0x00000004 -> 0x56
0x00000005 -> 0x45
0x00000006 -> 0x20
0x00000007 -> 0x59
0x00000008 -> 0x4F
0x00000009 -> 0x55
0x0000000A -> 0x21
...

整型 : 1234 = 0x04D2 (小端存放)
0x00000000 -> 0xD2
0x00000001 -> 0x04
...

现在我们来进行转换 : 
825440054 = 0x31333736
926102068 = 0x37333234
然后要让
String 的第 0-3 个字节和 825440054(0x31333736) 相等
String 的第 4-7 个字节和 926102068(0x37333234) 相等
因此内存的排布应该是 : 
0x00000000 -> 0x36
0x00000001 -> 0x37
0x00000002 -> 0x33
0x00000003 -> 0x31
0x00000004 -> 0x34
0x00000005 -> 0x32
0x00000006 -> 0x33
0x00000007 -> 0x37
因此这个字符串是 : 
char key = {0x36, 0x37, 0x33, 0x31, 0x34, 0x32, 0x33, 0x37};
用 ascii 表反查就可以得到 key = "67314237"
```
